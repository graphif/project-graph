# 文本节点功能实现难度分析

## 1. 当前实现情况

- **形状**：所有文本节点均为矩形，使用 `Rectangle` 类定义
- **字体大小**：固定为 `Renderer.FONT_SIZE = 32`
- **节点大小**：支持自动调整或手动调整
- **渲染流程**：统一使用矩形渲染逻辑

## 2. 不同字体大小的文本节点

### 实现要点

1. **属性扩展**：在 `TextNode` 类中添加 `fontSize` 属性
2. **尺寸计算**：修改 `adjustSizeByText` 方法，使用节点自身字体大小
3. **渲染逻辑**：修改 `renderTextNodeTextLayer` 方法，使用节点自身字体大小
4. **向后兼容**：为现有节点设置默认字体大小
5. **工具函数适配**：确保 `getMultiLineTextSize` 等函数使用正确的字体大小

### 影响范围

- `TextNode` 类：添加属性和修改尺寸计算
- `TextNodeRenderer` 类：修改文本渲染逻辑
- `Renderer` 类：可能需要调整默认值
- 相关工具函数：确保参数传递正确

### 实现难度

**低**：主要是属性添加和参数传递，改动相对集中，风险较小

## 3. 不同形状的文本节点

### 实现要点

1. **数据结构修改**：将 `collisionBox.shapes[0]` 从固定 `Rectangle` 改为支持多种形状
2. **渲染逻辑扩展**：根据不同形状调用不同的渲染方法
3. **碰撞检测适配**：确保不同形状的碰撞检测正确
4. **调整大小逻辑**：不同形状的调整方式差异很大
5. **兼容性处理**：处理依赖矩形属性的现有代码

### 影响范围

- `TextNode` 类：核心数据结构修改
- `TextNodeRenderer` 类：大幅修改渲染逻辑
- `CollisionBox` 相关：碰撞检测逻辑调整
- 调整大小控制器：需要支持不同形状
- 多处依赖矩形属性的代码：需要适配

### 实现难度

**高**：涉及核心数据结构和多个模块，改动范围广，风险大，需要处理复杂的边缘情况

## 4. 建议实现顺序

### 先实现不同字体大小的文本节点

**理由**：

1. 实现难度低，风险小
2. 用户需求可能更迫切（字体大小调整是常见需求）
3. 改动集中，易于测试和维护
4. 为后续实现不同形状奠定基础
5. 可以快速看到效果，提升用户体验

### 后实现不同形状的文本节点

**理由**：

1. 实现难度高，需要更多的设计和测试
2. 可以基于字体大小调整的经验进行设计
3. 可以先收集用户对形状的具体需求
4. 避免一次性引入过多复杂性

## 5. 关键修改点

### 字体大小调整关键修改

1. **TextNode.tsx**：添加 `fontSize` 属性，修改 `adjustSizeByText` 方法
2. **TextNodeRenderer.tsx**：修改 `renderTextNodeTextLayer` 方法，使用节点的字体大小
3. **Renderer.tsx**：保留 `FONT_SIZE` 作为默认值
4. **font.tsx**：确保文本测量函数正确使用传入的字体大小

### 不同形状关键修改（未来）

1. **TextNode.tsx**：修改 `collisionBox` 处理逻辑，支持多种形状
2. **TextNodeRenderer.tsx**：添加不同形状的渲染分支
3. **CollisionBox** 相关：增强碰撞检测支持
4. **调整大小控制器**：支持不同形状的调整方式

## 结论

**建议先实现不同字体大小的文本节点**，因为其实现难度低、风险小、用户需求迫切，可以快速提升用户体验。不同形状的文本节点可以在后续版本中实现，需要更多的设计和开发工作。
